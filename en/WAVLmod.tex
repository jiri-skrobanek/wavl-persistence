\section{Alternative WAVL Tree Balancing Algorithm}

For the purposes of full persistence, standard algorithm for working with WAVL trees cannot be used. It is guaranteed that no more than one rotation occurs during insert or delete. Nonetheless, the number of rank changes can be up to $O(\log n)$. 

Fortunately, the algorithm can be modified in such a way that no operation requires more than $O(1)$ changes. It will come with the price of substantially more complicated rules for balancing though. Given that WAVL trees compared to AVL trees already have noticeably more complicated implementation, this makes the structure ill suited for the use as basic binary search tree. 

The problems in WAVL trees arose from promote and demote operations which can propagate along a path from the inserted (respectively deleted) vertex all the way to the root. Fortunately, there is a remedy for this. 

We will call the sequence of vertices that had their ranks increased by promote during one insertion a {\em promotion path}. Similarly, all vertices demoted during one deletion will be refered to as a {\em demotion path}.

Let us refer to them both as {\em modifying paths}. Our modified algorithm handles all changes along such paths that were made during one insert or delete as just a constant number of modifications. Existence of a modifying path is only indicated at the top vertex of such a path. As it will turn out, only a constant number of such paths is created or modified using the standard balancing rules during an insert or delete operation. With the required rotations and change in ranks of a constant number of vertices, these are the only changes performed by our alternative algorithm in one operation.

To keep track of all modifying paths, three extra bits are added to each vertex to identify if it is a top of promotion, demotion or two demotion paths. A pointer to bottom of each modifying path is also added, being null for vertices where not enough paths are avialable.

When a vertex is a part of modifying path, its children's ranks must not change (or even their children in case of demotion that also changes rank of one children). We allow a vertex to be a part of at most one promotion or at most two demotion paths at any time, how this is achieved will become apparent from the procedures for insert and delete. In principle, when a vertex should be demoted, it is added to a demotion path. If it were already demoted though, meaning that it must be have a 1-son that is a (2,2)-vertex, then it is added to another demotion path. This is the only scenario where subsequent adding to a path is required, otherwise operations on vertices on paths cause these vertices to be removed from all paths they are on.

When descending down the tree, it is easy to determine where we leave the modifying path. When we compare the value of a vertex to searched key, we also compare to the end of modifying path and if the comaprison outcomes differ, we leave the path at this vertex. Rank of vertices that belong to a modifying path can be inferred rather easily. If we know that a promotion path continues here, the value should be increased by one. If two demotion paths continue through, rank should be reduced by 2 and rank of its child not on the demotion path should be decreased be 1. If one demotion path continues through, the type of demotion is determined from the rank of the child not on the path. The only tricky part is the second case of demote where rank of vertices not on the path is decreased, although this poses a mere inconvenience for implementation, not a fundamental problem.

Next we describe auxiliary procedures used for keeping the tree balanced. These are relied upon by insert and delete.

\subsection{Cut top from modifying path}

A vertex that is the top of a modifying path is excluded from that path and its rank is adjusted. Then, if there is one last vertex remaining on the path, it has its rank adjusted and the path is destroyed completely.

\subsection{Walk to key}

Walk descends from the root of the tree to a specified key and builds a temporary {\em walking path} of vertices corresponding to those visited on the path from root to searched key. Modifications by paths are written to those temporary vertices. The type of modification is stored and also pointer to the top of that path in the walking path.

\subsection{Remove from demotion path}

This procedure is given a vertex $V$ on a walking path that is also part of a demotion path. The demotion path is split in two parts with $V$ separating them. If $V$ is part of two demotion paths this is done for both of those. This is achieved by modifying the vertex on top the demotion path and the vertex directly below $V$. There can only be one part if $V$ lies on the end of the demotion path. Should any of the new parts be a single vertex, it is demoted immediately. $V$ is demoted.

The changes are written both to the walking path and the ranked tree. Since the top of modifying path changed for the bottom part, top must be updated for those vertices in the walking path.

We see that this operation will update at most three vertices in the tree.

\subsection{Remove from promotion path}

Very analogous to previous operation with the only difference being promotion in place of demotion.

We see that this operation will also update at most three vertices in the tree.

\subsection{Rotate promotion}

This procedure receives a vertex on a walking path where the rank rule is violated and (double) rotation is necessary. It is assumed that it is not part of any modifying path and that its $0$-child on the walking path is neither. 

It should be noted that the specified vertex will have a child on the walking path. This follows from the fact that a parent of a newly inserted leaf will not be a $(0,2)$ vertex.

The kind of rotation needed can be deduced locally. Should there be additional modifications from modifying paths, these will be apparent (as marked as such at the top of corresponding modifying path). 

Required rotation is performed, it may be needed to remove one more vertex from modifying path in case of double rotation.

It suffices to write all changes to the original ranked tree since balancing will end by this step and walking path will be abandoned. 
This procedure returns a new root of the tree, this is either the the original root or the vertex that was rotated above.

\subsection{Rotate demotion}

This procedure receives a vertex $V$ on a walking path where the rank rule is violated and (double) rotation is necessary. It is assumed that it is not part of any modifying path and that its $3$-child is neither. 

Again, if the walking path continues below $V$, the 3-child must lay on it. The kind of rotation is deduced from the other child of $V$ and its children. If those vertices need to be rotated and lie on a modifying path, they need to be removed from it. It can be seen that in such a case they form tops of their paths and the special operation described above can be used.

It suffices to write all changes to the original ranked tree since balancing will end by this step and walking path will be abandoned. New root is returned.

\subsection{Pass promotion up}

A walking path is passed as argument, the bottom vertex needs to be promoted. The promotion is propagated above the path while needed. One of the following actions is taken at each vertex $V$ based on its relation to modifying paths.

\begin{itemize}

\item {\bfseries $V$ is not part of any path} First we check whether promote or rotation will be needed. If rotation is needed, perform it. If promote is needed, the process proceeds to parent vertex.

\item {\bfseries $V$ has its rank demoted by parent} Parent must be removed from all paths it is on. If the rank is decreased by two, rotation will be required. Top of promotion path is marked.

\item {\bfseries $V$ is part of a promotion path} If $V$ is a (1,1)-vertex, mark its son as top of promotion path, remove $V$ from promotion path. Otherwise mark $V$'s son's son as top of promotion path, write $V$'s son's promotion directly, remove $V$ from promotion path and proceed with promote rotation. 

\item {\bfseries $V$ is part of one demotion path} If $V$ is a (1,1)-vertex, mark its son as top of demotion path, remove $V$ from demotion path. Otherwise mark $V$'s son's son as top of demotion path, write $V$'s son's demotion directly, remove $V$ from promotion path and procedd with promote rotation.

\item {\bfseries $V$ is part of two demotion paths} This vertex is removed from both demotion paths and its son becomes the top of new promotion path.

\end{itemize}

\subsection{Pass demotion up}

A walking path is passed as argument, the bottom vertex is not a leaf and needs to be demoted. The demotion is propagated above the path while needed. One of the following actions is taken at each vertex $V$ based on its relation to modifying paths.

\begin{itemize}

\item {\bfseries $V$ is not part of any path} If $V$ does not have a 3-son, mark the predecessor as top of demotion path. If the last vertex is reached, mark it as top of demotion path.  Otherwise inspect ranks of children and determine whether rotaion or demotion is needed. In case of demotion, continue to next vertex. In case of rotation, write demote of $V$'s son, mark $V$'s son's son as top of demotion path, procedd with demote rotation.

\item {\bfseries $V$ has its rank demoted by parent} Remove $V$'s parent from all demotion paths. Mark either this vertex or its son as a top of new demotion path.

\item {\bfseries $V$ is part of a promotion path} If $V$ is a (2,2)-vertex, mark its son as top of demotion path, remove $V$ from promotion path. Otherwise mark $V$'s son's son as top of demotion path, write $V$'s son's demotion directly, remove $V$ from promotion path and proceed with demote rotation. 

\item {\bfseries $V$ is part of one demotion path} If $V$ is a (2,2)-vertex, mark its son as top of demotion path, remove $V$ from demotion path. If second demote is required, continue to parent. Otherwise mark $V$'s son's son as top of demotion path, write $V$'s son's demotion directly, remove $V$ from promotion path and procedd with demote rotation. 

\item {\bfseries $V$ is part of two demotion paths} A rotation is requred, remove $V$ from both demotion paths. Otherwise mark $V$'s son's son as top of demotion path, write $V$'s son's demotion directly, remove $V$ from promotion path and procedd with demote rotation.

\end{itemize}

In fact, should the path be too short (1 vertex), instead of marking it, it is possible to directly change vertex ranks.

\subsection{Balance walking path}

We start ascension from the bottom of the walking back to the root. We use the walking path to be aware of true ranks. If promotion is needed, it passed up. If demotion is needed it is passed up. If rotation is needed, it is performed. New top of the tree is returned. 

The following operations form the interface of the WAVL tree.

\subsection{Find, Predecessor \& Successor}

Since promote and demote steps do not change the structure of the tree (they only change the ranks), all searching operations remain identical to their counterparts in standard algorithm.

\subsection{Insert}

A new vertex is inserted in the obvious place in the tree. A walking path is obtained to the parent and balanced subsequently.

\subsection{Delete}

The process is very similar to insert. First, if the vertex cannot be deleted directly, the vertex bearing the next lower/higher key must be identified and the keys \& values exchanged. Then search for the key about to be deleted (which is now in a vertex with only one child) starts from the root. If the vertex found is a leaf, walking path is obtained to the parent of it and balanced. Otherwise its child is deleted and walking path to it is balanced.

The proposition below follows from this algorithm.

\begin{prop}
WAVL tree can be stored in such a way that $\mathcal{O}(1)$ modifications of the structure are needed for insert and delete, while $\mathcal{O}(n)$ space is needed to store the structure and complexity of operation with the tree remains $\mathcal{O}(\log n)$.
\end{prop}

\begin{figure}
\begin{center}
\begin{tikzpicture}[sibling distance=8pt]
\Tree
[
.~
\edge node[auto=right] {1};
[ 
    .~
    \edge node[auto=right] {1};
    [  .~ \edge node[auto=right] {1}; [.~ \edge node[auto=right] {0}; X \edge[blank]; \node[blank]{}; ] \edge node[auto=left] {1}; ~ ]
    \edge node[auto=left] {1};
    [ .~ \edge node[auto=right] {1}; ~ \edge node[auto=left] {1}; ~ ]
] 
\edge node[auto=left] {1};
[ 
    .~
    \edge node[auto=right] {1};
    [  .~ \edge node[auto=right] {1}; ~ \edge node[auto=left] {1}; ~ ]
    \edge node[auto=left] {1};
    [ .~ \edge node[auto=right] {1}; ~ \edge node[auto=left] {1}; ~ ]
]
]
\end{tikzpicture}
\qquad
\begin{tikzpicture}[sibling distance=8pt]
\Tree
[
.\node[red]{~};
\edge[red] node[auto=right] {1};
[ 
    .\node[red]{~};
    \edge[red] node[auto=right] {1};
    [  .\node[red]{~}; \edge[red] node[auto=right] {1}; [.\node[red]{~}; \edge node[auto=right] {1}; X \edge[blank]; \node[blank]{}; ] \edge node[auto=left] {2}; ~ ]
    \edge node[auto=left] {2};
    [ .~ \edge node[auto=right] {1}; ~ \edge node[auto=left] {1}; ~ ]
] 
\edge node[auto=left] {2};
[ 
    .~
    \edge node[auto=right] {1};
    [  .~ \edge node[auto=right] {1}; ~ \edge node[auto=left] {1}; ~ ]
    \edge node[auto=left] {1};
    [ .~ \edge node[auto=right] {1}; ~ \edge node[auto=left] {1}; ~ ]
]
]
\end{tikzpicture}
\end{center}
\caption{Exemplar promotion path creation}
\end{figure}

\begin{figure}
\begin{center}
\begin{tikzpicture}[sibling distance=8pt]
\Tree
[ \edge node[auto=right]{2}; [.Y
    \edge node[auto=right] {3};
    \node[draw,triangle]{~};
    \edge node[auto=left] {2};
    [.~ \edge node[auto=right] {2}; \node[draw,triangle]{~}; \edge node[auto=left] {2}; \node[draw,triangle]{~};]
] ]
\end{tikzpicture}
\qquad
\begin{tikzpicture}[sibling distance=8pt]
\Tree
[ \edge node[auto=right]{2}; [.Y
    \edge node[auto=right] {2};
    \node[draw,triangle]{~};
    \edge node[auto=left] {1};
    [.~ \edge node[auto=right] {2}; \node[draw,triangle]{~}; \edge node[auto=left] {2}; \node[draw,triangle]{~};]
] ]
\end{tikzpicture}
\qquad
\begin{tikzpicture}[sibling distance=8pt]
\Tree
[ \edge node[auto=right]{2}; [.Y
    \edge node[auto=right] {3};
    \node[draw,triangle]{~};
    \edge node[auto=left] {1};
    [.~ \edge node[auto=right] {2}; \node[draw,triangle]{~}; \edge node[auto=left] {2}; \node[draw,triangle]{~};]
] ]
\end{tikzpicture}
\qquad
\begin{tikzpicture}[sibling distance=8pt]
\Tree
[ \edge node[auto=right]{2}; [.Y
    \edge node[auto=right] {2};
    \node[draw,triangle]{~};
    \edge node[auto=left] {1};
    [.~ \edge node[auto=right] {1}; \node[draw,triangle]{~}; \edge node[auto=left] {1}; \node[draw,triangle]{~};]
] ]
\end{tikzpicture}
\end{center}
\caption{The only case where double demotion can arise}
\end{figure}
